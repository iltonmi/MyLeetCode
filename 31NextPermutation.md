# 31. Next Permutation

字典序相关，找规律题。

**网络上的答案：**都是直接从后面看的，但是这样理解起来不直观，因为一般人查字典都不是倒着查的。

**问题关键：**找到字典序的规律。

**字典序规律如下:**

1. 最小的字典序，单调递增。
2. 最大的字典序单调递减。

**开始找规律：**

1. 猜想：从**整体**来看，字典排序就是从单调递增到单调递减的过程。
2. 思考：**局部**情况如何呢？
3. 观察以下情况：
   1. 寻找[1, 2, 3, 4, 5]的下一个排列。1有必要变吗？没。2呢？没。3呢？没。4呢？可以。
   2. 就变成了[1, 2, 3, 5, 4]。为什么1，2，3都不需要变化呢？因为后面还没排列完！！！！
   3. 这里因为4后面只剩一个5了，没得选。没有发现，继续找下一个排列。
   4. 继续变：[1, 2, 4, 3, 5]。这里3后面已经排列完成了，3需要被替换，所以从后面找一个替代的数。
   5. 找哪个呢？**因为是字典序递增，所以这个数必须从比3大的数中找出，然后从这堆数里选出最小的。**
   6. 到这一步，只剩下**最后一个问题：** 如何判断后面排列完成了没有？
   7. 正经说就是：**为了找到下一个排列，后面哪一部分需要变动呢？**

**寻找后面的需要变动的部分：**

1. 我们发现 [1, 2, 3, 5, 4] 到 [1, 2, 4, 3, 5]，被替换的3后面的序列是单调递减的。
2. 再观察[1, 2, 5, 4, 3]及其下一个排列[1, 3, 2, 4, 5]，被替换的2后面的序列是单调递减的。
3. 那么，缩小问题范围：**如果出现递增和递减反复出现，那么应该替换哪一个递减区域前面的数字呢?**

**替换哪一个递减区域前面的数字呢?**

1. 举个例子：[1, 4, 3, 2, 7, 6, 5]及其下一个序列[1, 4, 3, 5, 2, 6, 7]，这里2后面的序列单调递减，即已排列完成，所以我们选择的是第2个即最后一个递减区域。
2. 再举一个例子：[1, 3, 2, 5, 4, 7, 6]及其下一个序列[1, 3, 2, 5, 6, 4, 7]，这里4后面的序列单调递减，即已排列完成，所以我们选择的是第3个即最后一个递减区域。
3. ok，我们选择的是最后一个递减区域。
4. 还有一个问题没解决：**替换数字后，被替换的数字和最后一个递减区域中没有用于替换的数字组成的集合，应该如何排列呢？**
5. 正经说就是：**对于被替换位置后面的数字，如何重新排列？**

**找到重新排列的方法：**

1. 回到字典序的定义，一个新的排列，其实就是单调递增的最小排列。

**总结：**

1. 找到最后一个递减区域，确定被替换的数字。
2. 从递减区域中找到比被替换数大的最小数（注意是更大，相等的替换不改变字典序）。
3. 对递减区域按照单调递增重新排列。

上代码：时间O(n)，空间O(1)。

```java
public void nextPermutation(int[] nums) {
    if(nums == null || nums.length <= 1) {
        return;
    }
    int i = nums.length - 2;
    for(; i >= 0 && nums[i] >= nums[i + 1]; i--) {}
    if(i < 0) {
        reverse(nums, 0, nums.length - 1);
        return;
    }
    int j = i + 1;
    for(; j < nums.length && nums[j] > nums[i]; j++) {}
    swap(nums, j - 1, i);
    //替换后，递减区域单调性不变，直接对递减区域进行进行翻转
    reverse(nums, i + 1, nums.length - 1);
}

private void reverse(int[] arr, int left, int right) {
    while(left < right) {
        swap(arr, left++, right--);
    }
}

private void swap(int[] arr, int ai, int bi) {
    int temp = arr[ai];
    arr[ai] = arr[bi];
    arr[bi] = temp;
}
```

